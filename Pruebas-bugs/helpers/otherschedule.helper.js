import OtherSchedules from "../models/OthersSchedule.js";
import { dateFormater, formatDate12Hours } from "../utils/functions/dates.js";

/**
 * Helper object for other schedules.
 */
const otherScheduleHelper = {};

/**
 * Validates if a schedule exists by ID.
 * @param {string} id - The ID of the schedule to validate.
 * @throws {Error} If the schedule does not exist.
 */
otherScheduleHelper.validateExistScheduleById = async (id) => {
  try {
    const schedule = await OtherSchedules.findById(id, { status: 0 });
    if (!schedule) {
      throw new Error();
    }
  } catch (error) {
    throw new Error("El horario no existe");
  }
};

/**
 * Validates if a schedule conflicts with an instructor's existing schedules.
 * @param {string} instructor - The ID of the instructor.
 * @param {number[]} days - An array of days of the week (0-6) when the schedule occurs.
 * @param {string} fstart - The start date of the schedule.
 * @param {string} fend - The end date of the schedule.
 * @param {string} tstart - The start time of the schedule.
 * @param {string} tend - The end time of the schedule.
 * @throws {Error} If the schedule conflicts with an existing schedule.
 */
otherScheduleHelper.validateOtherSchedule = async (
  program,
  instructor,
  days,
  fstart,
  fend,
  tstart,
  tend,
  req
) => {
  let datesWarning = [];
  let newListPrograma = [];
  let schedules = [];
  let daysProgram = [];
  try {
    let currentDate = dateFormater(fstart);
    const fstartShe = dateFormater(fstart);
    const fendShe = dateFormater(fend);

    const dateNow = new Date();
    const tStartToDateClient = dateFormater(dateNow, tstart);
    const tEndToDateClient = dateFormater(dateNow, tend);

    if (program) {
      schedules = await OtherSchedules.find({
        instructor,
        status: 0,
        _id: { $ne: program },
      });
    } else {
      schedules = await OtherSchedules.find({
        instructor,
        status: 0,
      });
    }

    while (currentDate <= fendShe) {
      if (days.includes(currentDate.getUTCDay())) {
        //extraer solo lo que está entes del T
        let result = currentDate.toISOString().split("T")[0];
        daysProgram.push(result); // ["2021-05-01", "2021-05-02", "2021-05-03"]
      }
      // next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    //validar que ni fstart y fend esten dentro de las fechas de la programacion

    for (const schedule of schedules) {
      const tStartToDate = dateFormater(dateNow, schedule.tstart);
      const tEndToDate = dateFormater(dateNow, schedule.tend);

      if (
        schedule.fstart <= fendShe &&
        schedule.fend >= fstartShe &&
        tStartToDate <= tEndToDateClient &&
        tEndToDate >= tStartToDateClient
      ) {
        newListPrograma.push(schedule);
      }
    }

    if (newListPrograma.length > 0) {
      for (const programa of newListPrograma) {
        for (const event of programa.events) {
          let result = event.toISOString().split("T")[0];
          if (daysProgram.includes(result)) {
            datesWarning.push(
              result +
                " " +
                formatDate12Hours(programa.tstart) +
                " - " +
                formatDate12Hours(programa.tend)
            );
          }
        }
      }
    }

    if (datesWarning.length > 0) {
      datesWarning = datesWarning.join(", ");

      req.validation =
        "El instructor ya tiene programación en las fechas " + datesWarning;
    }
  } catch (error) {
    throw new Error(
      "Error al validar la programación, revise los datos e intente de nuevo"
    );
  }
};

otherScheduleHelper.validateSaveOtherSchedule = async (
  program,
  instructor,
  fstart,
  fend,
  tstart,
  tend,
  events
) => {

  let existError = "";
  let newListEvents = [];
  let newListPrograma = [];
  let schedules = [];
  try {
    const fstartShe = dateFormater(fstart);
    const fendShe = dateFormater(fend);

    const dateNow = new Date();
    const tStartToDateClient = dateFormater(dateNow, tstart);
    const tEndToDateClient = dateFormater(dateNow, tend);

    //extraer solo la start de cada evento y validar que idInstructor sea igual a instructor
    for (const event of events) {
      if (event.idInstructor == instructor && event.autogenerated == true) {
        if (event.start != null || event.start != undefined) {
          newListEvents.push(event.start);
        }
      }
    }

    if (program) {
      schedules = await OtherSchedules.find({
        instructor,
        status: 0,
        _id: { $ne: program },
      });
    } else {
      schedules = await OtherSchedules.find({
        instructor,
        status: 0,
      });
    }

    //validar que ni fstart y fend esten dentro de las fechas de la programacion
    for (const schedule of schedules) {
      const tStartToDate = dateFormater(dateNow, schedule.tstart);
      const tEndToDate = dateFormater(dateNow, schedule.tend);

      if (
        schedule.fstart <= fendShe &&
        schedule.fend >= fstartShe &&
        tStartToDate <= tEndToDateClient &&
        tEndToDate >= tStartToDateClient
      ) {
        newListPrograma.push(schedule);
      }
    }

    if (newListPrograma.length > 0) {
        for (const programa of newListPrograma) {
          for (const event of programa.events) {
          let result = event.toISOString().split("T")[0];
          if (newListEvents.includes(result)) {
            existError = `El instructor ya tiene programación en la fecha ${result} y en la hora ${formatDate12Hours(
              programa.tstart
            )} - ${formatDate12Hours(programa.tend)}`;
            break;
          }
        };
        if (existError) throw new Error(existError);
      };
    }
  } catch (error) {
    console.log(error);
    if (existError) throw new Error(existError);
    else
      throw new Error(
        "Error al validar la programación, revise los datos e intente de nuevo"
      );
  }
};

otherScheduleHelper.validateActiveSchedule = async (id) => {
  let existError = "";
  const currentDate = new Date();
  try {
    const searchSchedule = await OtherSchedules.findById(id);
    if (searchSchedule.status == 1) {
      //buscar si hay programaciones activas con la misma ficha e instructor sin contar la programacion que se esta editando
      const schedules = await OtherSchedules.find({
        instructor: searchSchedule.instructor,
        status: 0,
        _id: { $ne: id },
      });
      const tStartToDateClient = dateFormater(
        currentDate,
        searchSchedule.tstart
      );
      const tEndToDateClient = dateFormater(currentDate, searchSchedule.tend);

        for(const schedule of schedules){
          const tStartToDate = dateFormater(currentDate, schedule.tstart);
          const tEndToDate = dateFormater(currentDate, schedule.tend);
          if (
            schedule.fstart <= searchSchedule.fend &&
            schedule.fend >= searchSchedule.fstart &&
            tStartToDate <= tEndToDateClient &&
            tEndToDate >= tStartToDateClient
          ) {
            schedule.events.forEach((event) => {
              if (
                event >= searchSchedule.fstart &&
                event <= searchSchedule.fend
              ) {
                if (searchSchedule.events.includes(event)) {
                  existError = `El instructor ya tiene programación activa en la fecha: ${
                    event.toISOString().split("T")[0]
                  }`;
                  return;
                }
              }
            });
          }
          if (existError) return;
        };
    }
  } catch (error) {
    console.log(e);
    if (existError) throw new Error(existError);
    else
      throw new Error(
        "Error al validar la programación, revise los datos e intente de nuevo"
      );
  }
};

export { otherScheduleHelper };
