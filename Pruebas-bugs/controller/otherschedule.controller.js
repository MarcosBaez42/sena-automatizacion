import colorsEvents from "../utils/colors/colorsEvents.js";
import {
  formatDate12Hours,
  calculateNumHoursWork,
} from "../utils/functions/dates.js";

import Schedule from "../models/Schedule.js";
import OtherSchedules from "../models/OthersSchedule.js";
import Instructor from "../models/Instructor.js";
import registerAction from "../middlewares/binnacle.js";
import {
  formatEventOtherSchedule,
  formatEventSchedule,
} from "../utils/functions/eventsCalender.js";

const otherScheduleCtrl = {};

//register new schedule in the db
otherScheduleCtrl.registerOtherSchedule = async (req, res) => {
  const {
    instructor,
    typeactivity,
    additionalactivity,
    fstart,
    fend,
    tstart,
    tend,
    justification,
    otheractivity,
    days,
    events,
  } = req.body;

  let newListOfEvents = [];
  //extraer solo la start de cada evento y validar que idInstructor sea igual a instructor
  events.forEach((event) => {
    if (event.idInstructor == instructor && event.autogenerated == true) {
      if (event.start != null || event.start != undefined) {
        newListOfEvents.push(event.start);
      }
    }
  });

  const hourswork = calculateNumHoursWork(tstart, tend, newListOfEvents.length);

  const searchInstructor = await Instructor.findById(instructor);
  let moreHours = searchInstructor.hourswork + hourswork;
  await Instructor.findByIdAndUpdate(instructor, { hourswork: moreHours });

  try {
    const newOtherSchedule = new OtherSchedules({
      instructor,
      typeactivity: typeactivity.toUpperCase().trim(),
      additionalactivity: additionalactivity.toUpperCase().trim(),
      otheractivity: otheractivity ? otheractivity.toUpperCase().trim() : '',
      hourswork,
      justification: justification.toUpperCase().trim(),
      days,
      fstart: newListOfEvents[0],
      fend: newListOfEvents[newListOfEvents.length - 1],
      tstart,
      tend,
      events: newListOfEvents,
    });
    await newOtherSchedule.save();
    await registerAction(
      "OTROS HORARIOS",
      {
        event: "REGISTRAR OTRO HORARIO",
        data: newOtherSchedule,
      },
      req.headers.token
    );
    res.json({ msg: "Horario registrado correctamente" });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//update schedule in the db
otherScheduleCtrl.updateOtherSchedule = async (req, res) => {
  const { id } = req.params;
  const {
    instructor,
    typeactivity,
    additionalactivity,
    otheractivity,
    fstart,
    fend,
    tstart,
    tend,
    days,
    justification,
    events,
  } = req.body;

  let newListOfEvents = [];
  //extraer solo la start de cada evento y validar que idInstructor sea igual a instructor
  events.map((event) => {
    if (event.idInstructor == instructor && event.autogenerated == true) {
      if (event.start != null || event.start != undefined) {
        newListOfEvents.push(event.start);
      }
    }
  });

  const hourswork = calculateNumHoursWork(tstart, tend, newListOfEvents.length);
  //buscar el horario anterior para actualizar las horas del instructor
  const oldOtherSchedule = await OtherSchedules.findById(id);
  const oldWorkHours = oldOtherSchedule.hourswork;

  //si el instructor es diferente al anterior actualizar las horas de trabajo del antiguo instructor
  if (oldOtherSchedule.instructor != instructor) {
    //restar las horas de trabajo del instructor anterior
    const oldInstructor = await Instructor.findById(
      oldOtherSchedule.instructor
    );
    let lessHours = oldInstructor.hourswork - oldOtherSchedule.hourswork;
    await Instructor.findByIdAndUpdate(oldOtherSchedule.instructor, {
      hourswork: lessHours,
    });
  }

  const searchInstructor = await Instructor.findById(instructor);
  let oldHoursInst = searchInstructor.hourswork;
  let newHoursInst = 0;

  if (oldWorkHours != hourswork) {
    if (oldWorkHours > hourswork) {
      newHoursInst = oldHoursInst - (oldWorkHours - hourswork);
    } else {
      newHoursInst = oldHoursInst + (hourswork - oldWorkHours);
    }
    await Instructor.findByIdAndUpdate(instructor, { hourswork: newHoursInst });
  } else {
    if (oldOtherSchedule.instructor != instructor) {
      let newHours = oldHoursInst + hourswork;

      await Instructor.findByIdAndUpdate(instructor, { hourswork: newHours });
    }
  }

  try {
    await OtherSchedules.findByIdAndUpdate(id, {
      instructor,
      typeactivity: typeactivity.toUpperCase().trim(),
      additionalactivity: additionalactivity.toUpperCase().trim(),
      otheractivity: otheractivity ? otheractivity.toUpperCase().trim() : '',
      hourswork,
      days,
      justification: justification.toUpperCase().trim(),
      fstart: newListOfEvents[0],
      fend: newListOfEvents[newListOfEvents.length - 1],
      tstart,
      tend,
      events: newListOfEvents,
    });
    await registerAction(
      "OTROS HORARIOS",
      {
        event: "ACTUALIZAR OTRO HORARIO",
        data: {
          id,
          instructor,
          typeactivity,
          additionalactivity,
          hourswork,
          days,
          fstart: newListOfEvents[0],
          fend: newListOfEvents[newListOfEvents.length - 1],
          tstart,
          tend,
        },
      },
      req.headers.token
    );
    res.json({ msg: "Horario actualizado correctamente" });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//validate before register schedule
otherScheduleCtrl.getDataValidateOtherSchedule = async (req, res) => {
  const {
    instructor,
    typeactivity,
    additionalactivity,
    days,
    fstart,
    fend,
    tstart,
    tend,
    justification,
  } = req.body;
  let nameInstructor = "";
  let idInstructor = "";
  let colors = [...colorsEvents];

  try {
    const findInstructor = await Instructor.findById(instructor, { status: 0 });
    nameInstructor = findInstructor.name;
    idInstructor = findInstructor._id;

    let daysProgram = [];
    let currentDate = new Date(fstart);
    let fechaStart = new Date(fstart);
    let fechaFin = new Date(fend);
    let index = 1;
    //generar las fehcas start para el instructor que se desea programar

    while (currentDate <= fechaFin) {
      if (days.includes(currentDate.getUTCDay())) {
        //extraer solo lo que está entes del T
        let result = currentDate.toISOString().split("T")[0];
        daysProgram.push({
          id: index,
          idInstructor: idInstructor,
          typeactivity,
          additionalactivity,
          justification,
          title: nameInstructor,
          start: result,
          tstart: formatDate12Hours(tstart),
          tend: formatDate12Hours(tend),
          type: 1,
          autogenerated: true,
        });
        index++;
      }
      // next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    //buscar los events de la misma ficha dentro del rango de fechas
    const searchOtheSchedule = await OtherSchedules.find({
      instructor,
      status: 0,
    }).populate("instructor");

    let newListPrograma = [];

    searchOtheSchedule.forEach((progra) => {
      if (progra.fstart <= fechaFin && progra.fend >= fechaStart) {
        newListPrograma.push(progra);
      }
    });

    //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
    newListPrograma.forEach((progra) => {
      //selecionar un color aleatorio para cada instructor
      const color = colors[Math.floor(Math.random() * colors.length)];
      colors.splice(colors.indexOf(color), 1);

      progra.events.forEach((event) => {
        daysProgram.push(formatEventOtherSchedule(progra,event, index, color, false));
        index++;
      });
    });

    const schedules = await Schedule.find({
      instructor,
      status: 0,
    }).populate("fiche instructor program competence outcome environment");

    let newListOfSchedules = [];

    schedules.forEach((progra) => {
      if (progra.fstart <= fechaFin && progra.fend >= fechaStart) {
        newListOfSchedules.push(progra);
      }
    });

    //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
    newListOfSchedules.forEach((progra) => {
      //selecionar un color aleatorio para cada instructor
      const color = colors[Math.floor(Math.random() * colors.length)];
      colors.splice(colors.indexOf(color), 1);

      progra.events.forEach((event) => {
        daysProgram.push(formatEventSchedule(progra,event, index, color, false));
        index++;
      });
    });
    res.json({
      events: daysProgram,
      msg: req.validation ? req.validation : "",
    });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//validate edit schedule
otherScheduleCtrl.getDataValidateEditOtherSchedule = async (req, res) => {
  const {
    instructor,
    typeactivity,
    additionalactivity,
    days,
    fstart,
    fend,
    tstart,
    tend,
    justification,
  } = req.body;
  const idSchedule = req.params.id;

  let nameInstructor = "";
  let idInstructor = "";
  let colors = [...colorsEvents];

  try {
    const findInstructor = await Instructor.findById(instructor, { status: 0 });
    nameInstructor = findInstructor.name;
    idInstructor = findInstructor._id;

    let daysProgram = [];
    let currentDate = new Date(fstart);
    let fechaStart = new Date(fstart);
    let fechaFin = new Date(fend);
    let index = 1;
    //generar las fehcas start para el instructor que se desea programar

    while (currentDate <= fechaFin) {
      if (days.includes(currentDate.getUTCDay())) {
        //extraer solo lo que está entes del T
        let result = currentDate.toISOString().split("T")[0];
        daysProgram.push({
          id: index,
          idInstructor: idInstructor,
          typeactivity,
          additionalactivity,
          justification,
          title: nameInstructor,
          start: result,
          tstart: formatDate12Hours(tstart),
          tend: formatDate12Hours(tend),
          type: 1,
          autogenerated: true,
        });
        index++;
      }
      // next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    //buscar los events de la misma ficha dentro del rango de fechas
    const searchOtherSchedule = await OtherSchedules.find({
      instructor,
      status: 0,
    }).populate("instructor");

    let newListPrograma = [];

    searchOtherSchedule.forEach((progra) => {
      if (progra.fstart <= fechaFin && progra.fend >= fechaStart) {
        newListPrograma.push(progra);
      }
    });

    //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
    newListPrograma.forEach((progra) => {
      if (idSchedule.toString() != progra._id.toString()) {
        //selecionar un color aleatorio para cada instructor
        const color = colors[Math.floor(Math.random() * colors.length)];
        colors.splice(colors.indexOf(color), 1);
        progra.events.forEach((event) => {
          daysProgram.push(
            formatEventOtherSchedule(progra,event, index, color, false)
          );
          index++;
        });
      }
    });

    /* 
   buscar los eventos de la misma ficha dentro del rango de fechas
   */

    const searchSchedule = await Schedule.find({
      instructor,
      status: 0,
    }).populate("fiche instructor program competence outcome environment");

    let newListSchedule = [];

    if (searchSchedule.length > 0) {
      searchSchedule.forEach((schedule) => {
        if (schedule.fstart <= fechaFin && schedule.fend >= fechaStart) {
          newListSchedule.push(schedule);
        }
      });

      if (newListSchedule.length > 0) {
        //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
        newListSchedule.forEach((schedule) => {
          //selecionar un color aleatorio para cada programacion
          const color = colors[Math.floor(Math.random() * colors.length)];
          colors.splice(colors.indexOf(color), 1);

          schedule.events.forEach((event) => {
            daysProgram.push(
              formatEventSchedule(schedule,event, index, color, false)
            );
            index++;
          });
        });
      }
    }

    res.json({
      events: daysProgram,
      msg: req.validation ? req.validation : "",
    });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get others schedules by instructor
otherScheduleCtrl.getOthersSchedulesInstructor = async (req, res) => {
  const { id } = req.params;
  try {
    const schedules = await OtherSchedules.find({
      instructor: id,
    }).populate("instructor");
    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get all schedules in the db
otherScheduleCtrl.getOthersSchedules = async (req, res) => {
  const { status } = req.query;
  try {
    const schedules = await OtherSchedules.find(status ? { status } : {})
      .populate("instructor")
      .sort({ createdAt: -1 });
    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get ultimate 100 schedules in the db
otherScheduleCtrl.getOtherSchedulesLimit = async (req, res) => {
  try {
    const schedules = await OtherSchedules.find({ status: 0 })
      .sort({ createdAt: -1 })
      .limit(100)
      .populate("instructor");
    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get schedule by id
otherScheduleCtrl.getOtherScheduleId = async (req, res) => {
  const { id } = req.params;
  try {
    let schedule = await OtherSchedules.findById(id).populate("instructor");

    let newSchedule = schedule.toObject();

    let newListEvents = [];
    let index = 1;

    newSchedule.events.forEach((event) => {
      newListEvents.push({
        id: index,
        code: schedule._id,
        idInstructor: schedule.instructor._id,
        typeactivity: schedule.typeactivity,
        additionalactivity: schedule.additionalactivity,
        justification: schedule.justification,
        title: schedule.instructor.name,
        start: event.toISOString().split("T")[0], //"2023-05-01"
        tstart: formatDate12Hours(schedule.tstart),
        tend: formatDate12Hours(schedule.tend),
        type: 1,
        autogenerated: false,
      });
      index++;
    });

    newSchedule.events = newListEvents;
    res.json(newSchedule);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//active schedule in the db
otherScheduleCtrl.activeOtherSchedule = async (req, res) => {
  const { id } = req.params;
  console.log("active "+id);
  
  try {
    const otherSchedule = await OtherSchedules.findByIdAndUpdate(
      id,
      { status: 0 },
      { new: true }
    );

    //sumar las horas de trabajo del instructor
    const instructor = await Instructor.findById(otherSchedule.instructor);
    const newHourswork = instructor.hourswork + otherSchedule.hourswork;
    await Instructor.findByIdAndUpdate(otherSchedule.instructor, {
      hourswork: newHourswork,
    });

    if (newHourswork > instructor.caphour) {
      return res.json({
        msg: "Horario activado correctamente",
        alert: "El instructor ha superado su limite de horas",
      });
    }
    await registerAction(
      "OTROS HORARIOS",
      {
        event: "ACTIVAR OTRO HORARIO",
        data: { id },
      },
      req.headers.token
    );
    return res.json({ msg: "Horario activado correctamente" });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//inactivate schedule in the db
otherScheduleCtrl.inactiveOtherSchedule = async (req, res) => {
  const { id } = req.params;
  console.log("inactive "+id);
  try {
    const otherSchedule = await OtherSchedules.findByIdAndUpdate(
      id,
      { status: 1 },
      { new: true }
    );

    //restar las horas de trabajo del instructor
    const instructor = await Instructor.findById(otherSchedule.instructor);
    const newHourswork = instructor.hourswork - otherSchedule.hourswork;
    await Instructor.findByIdAndUpdate(otherSchedule.instructor, {
      hourswork: newHourswork,
    });

    await registerAction(
      "OTROS HORARIOS",
      {
        event: "DESACTIVAR OTRO HORARIO",
        data: { id },
      },
      req.headers.token
    );
    res.json({ msg: "Horario inactivado correctamente" });
  } catch (error) {
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//delete schedule in the db
otherScheduleCtrl.deleteEventOtherSchedule = async (req, res) => {
  const { id } = req.params;
  const { event } = req.body;
  const eventFormat = `${event}T00:00:00.000Z`;

  try {
    const schedule = await OtherSchedules.findById(id);
    const instructor = await Instructor.findById(schedule.instructor);
    let oldHourswork = instructor.hourswork;

    if (schedule.events.length >= 1) {
      const newEvents = schedule.events.filter((event) => {
        return event.toISOString() != eventFormat;
      });
      const hourswork = calculateNumHoursWork(
        schedule.tstart,
        schedule.tend,
        newEvents.length
      );

      //restar las horas de trabajo del instructor
      oldHourswork -= schedule.hourswork - hourswork;

      await Instructor.findByIdAndUpdate(instructor._id, {
        hourswork: oldHourswork,
      });

      await OtherSchedules.findByIdAndUpdate(id, {
        fstart: newEvents[0],
        fend: newEvents[newEvents.length - 1],
        events: newEvents,
        hourswork,
      });
      await registerAction(
        "OTROS HORARIOS",
        {
          event: "ELIMINAR EVENTO OTRO HORARIO",
          data: { id, event },
        },
        req.headers.token
      );
      return res.json({ msg: "Evento eliminado correctamente" });
    } else {
      return res.status(400).json({
        msg: "Solo queda un evento en la programacion, no se puede eliminar",
      });
    }
  } catch (error) {
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

export { otherScheduleCtrl };
