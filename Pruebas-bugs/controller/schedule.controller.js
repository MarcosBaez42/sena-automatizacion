import colorsEvents from "../utils/colors/colorsEvents.js";
import { formatDate12Hours,calculateNumHoursWork, dateFormater } from "../utils/functions/dates.js";
import { formatEventSchedule } from "../utils/functions/eventsCalender.js";

import Schedule from "../models/Schedule.js";
import Instructor from "../models/Instructor.js";
import Fiche from "../models/Fiche.js";
import Environment from "../models/Environment.js";
import Program from "../models/Program.js";
import Outcome from "../models/Outcome.js";
import Competence from "../models/Competence.js";
import OtherSchedules from "../models/OthersSchedule.js";
import registerAction from "../middlewares/binnacle.js";
import HistorySchedule from "../models/HistorySchedule.js";

/**
 * Controller for handling schedules
 * @namespace scheduleCtrl
 */
const scheduleCtrl = {};

/**
 * Registers a new schedule in the database
 * @function
 * @memberof scheduleCtrl
 * @name registerSchedule
 * @param {Object} req - The request object
 * @param {Object} res - The response object
 * @returns {Promise<void>} A promise that resolves when the schedule is registered
 */
scheduleCtrl.registerSchedule = async (req, res) => {
  const {
    fiche,
    program,
    competence,
    outcome,
    instructor,
    supporttext,
    observation,
    environment,
    days,
    fstart,
    fend,
    tstart,
    tend,
    events,
  } = req.body;

  let newListOfEvents = [];
  //extraer solo la start de cada evento y validar que idInstructor sea igual a instructor
  events.forEach((event) => {
    if (event.idInstructor == instructor && event.autogenerated == true) {
      if (event.start != null || event.start != undefined) {
        newListOfEvents.push(event.start);
      }
    }
  });

  const hourswork = calculateNumHoursWork(tstart, tend, newListOfEvents.length);

  //actualizar las horas de trabajo del instructor
  const searchInstructor = await Instructor.findById(instructor);
  let moreHours = searchInstructor.hourswork + hourswork;
  await Instructor.findByIdAndUpdate(instructor, { hourswork: moreHours });

  try {
    const newSchedule = new Schedule({
      fiche,
      program,
      competence,
      outcome,
      instructor,
      supporttext: supporttext.toUpperCase().trim(),
      observation: observation.toUpperCase().trim(),
      environment,
      days,
      fstart: newListOfEvents[0],
      fend: newListOfEvents[newListOfEvents.length - 1],
      tstart,
      tend,
      hourswork,
      events: newListOfEvents,
    });
    await newSchedule.save();
    await registerAction(
      "HORARIO",
      {
        event: "REGISTRAR HORARIO",
        data: newSchedule,
      },
      req.headers.token
    );
    res.json({ msg: "Horario registrado correctamente" });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

/**
 * Updates a schedule in the database
 * @function
 * @memberof scheduleCtrl
 * @name updateSchedule
 * @param {Object} req - The request object
 * @param {Object} res - The response object
 * @returns {Promise<void>} A promise that resolves when the schedule is updated
 */
scheduleCtrl.updateSchedule = async (req, res) => {
  const { id } = req.params;
  const {
    competence,
    outcome,
    instructor,
    supporttext,
    observation,
    environment,
    days,
    tstart,
    tend,
    events,
  } = req.body;

  let newListOfEvents = [];
  //extraer solo la start de cada evento y validar que idInstructor sea igual a instructor
  events.map((event) => {
    if (event.idInstructor == instructor && event.autogenerated == true) {
      if (event.start != null || event.start != undefined) {
        newListOfEvents.push(event.start);
      }
    }
  });

  const hourswork = calculateNumHoursWork(tstart, tend, newListOfEvents.length);
  //buscar la programacion anterior para actualizar las horas de trabajo del instructor
  const oldSchedule = await Schedule.findById(id);
  const oldWorkHours = oldSchedule.hourswork;

  //si el instructor es diferente al anterior actualizar las horas de trabajo del antiguo instructor
  if (oldSchedule.instructor != instructor) {
    //restar las horas de trabajo del instructor anterior
    const oldInstructor = await Instructor.findById(oldSchedule.instructor);
    let lessHours = oldInstructor.hourswork - oldSchedule.hourswork;
    await Instructor.findByIdAndUpdate(oldSchedule.instructor, {
      hourswork: lessHours,
    });

    //verificar si existe ya un instructor en el mismo schedule
    const existHistory = await HistorySchedule.findOne({
      instructor: oldSchedule.instructor,
      shedule: oldSchedule._id,
    });

    if (existHistory) {
      //actualizar el instructor en el historial
      await HistorySchedule.findByIdAndUpdate(existHistory._id, {
        instructor,
        status: 0,
      });

    }else{
      //crear un nuevo registro en el historial
      const newHistory = new HistorySchedule({
        fiche: oldSchedule.fiche,
        instructor: oldSchedule.instructor,
        shedule: oldSchedule._id,
        status: 0,
      });
      await newHistory.save();
    }
  }

  const searchInstructor = await Instructor.findById(instructor);
  let oldHoursInst = searchInstructor.hourswork;
  let newHoursInst = 0;

  if (oldWorkHours != hourswork) {
    if (oldWorkHours > hourswork) {
      //sacar la diferencia de horas y restarlas al instructor
      newHoursInst = oldHoursInst - (oldWorkHours - hourswork);
    } else {
      //sacar la diferencia de horas y sumarlas al instructor
      newHoursInst = oldHoursInst + (hourswork - oldWorkHours);
    }

    //actualizar las horas de trabajo del instructor
    await Instructor.findByIdAndUpdate(instructor, { hourswork: newHoursInst });
  } else {
    if (oldSchedule.instructor != instructor) {
      let newHours = oldHoursInst + hourswork;

      await Instructor.findByIdAndUpdate(instructor, { hourswork: newHours });
    }
  }

  try {
    await Schedule.findByIdAndUpdate(id, {
      competence,
      outcome,
      supporttext,
      observation,
      environment,
      instructor,
      days,
      fstart: newListOfEvents[0],
      fend: newListOfEvents[newListOfEvents.length - 1],
      tstart,
      tend,
      hourswork,
      events: newListOfEvents,
    });
    await registerAction(
      "HORARIO",
      {
        event: "ACTUALIZAR HORARIO",
        data: { id, competence, outcome, supporttext, observation, environment ,instructor, days, tstart, tend, hourswork,fstart: newListOfEvents[0],fend: newListOfEvents[newListOfEvents.length - 1] },
      },
      req.headers.token
    );
    res.json({ msg: "Horario actualizado correctamente" });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//validate before register schedule

scheduleCtrl.getDataValidateSchedule = async (req, res) => {
  const {
    fiche,
    fstart,
    fend,
    instructor,
    days,
    tstart,
    tend,
    environment,
    program,
    outcome,
    competence,
  } = req.body;
  let nameInstructor = "";
  let idInstructor = "";
  let colors = [...colorsEvents];

  try {
    const searchFiche = await Fiche.findById(fiche);

    const findInstructor = await Instructor.findById(instructor, { status: 0 });
    nameInstructor = findInstructor.name;
    idInstructor = findInstructor._id;

    const searchCompetence = await Competence.findById(competence, {
      status: 0,
    });
    const searchOutcome = await Outcome.findById(outcome, { status: 0 });
    const searchProgram = await Program.findById(program, { status: 0 });
    const searchEnvironment = await Environment.findById(environment, {
      status: 0,
    });

    let daysProgram = [];
    let currentDate = dateFormater(fstart);
    let fechaStart = dateFormater(fstart);
    let fechaFin = dateFormater(fend);
    let index = 1;
    //generar las fehcas start para el instructor que se desea programar

    while (currentDate <= fechaFin) {
      if (days.includes(currentDate.getUTCDay())) {
        //extraer solo lo que está entes del T
        let result = currentDate.toISOString().split("T")[0];
        daysProgram.push({
          id: index,
          fiche: searchFiche.number,
          idInstructor: idInstructor,
          program: searchProgram.name,
          environment: searchEnvironment.name,
          outcome: searchOutcome.outcomes,
          competence: searchCompetence.name,
          title: nameInstructor,
          start: result,
          tstart: formatDate12Hours(tstart),
          tend: formatDate12Hours(tend),
          type: 0,
          autogenerated: true,
        });
        index++;
      }
      // next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    //buscar los events de la misma ficha dentro del rango de fechas
    const programaFiche = await Schedule.find({
      fiche: fiche,
      status: 0,
    })
      .populate("fiche instructor program competence outcome environment")

    let newListProgramaFiche = [];

    programaFiche.forEach((progra) => {
      if (progra.fstart <= fechaFin && progra.fend >= fechaStart) {
        newListProgramaFiche.push(progra);
      }
    });

    //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
    newListProgramaFiche.forEach((progra) => {
      //selecionar un color aleatorio para cada instructor
      const color = colors[Math.floor(Math.random() * colors.length)];
      colors.splice(colors.indexOf(color), 1);


      progra.events.forEach((event) => {
        daysProgram.push(
          formatEventSchedule(progra,event, index, color, false)
        );
        index++;
      });
    });


    /* 
    buscar los eventos de otras programaciones
    */

    const searchOtherSchedule = await OtherSchedules.find({
      instructor,
      status: 0,
    });

    let newListOtherSchedule = [];

    if (searchOtherSchedule.length > 0) {
      searchOtherSchedule.forEach((otherSchedule) => {
        if (
          otherSchedule.fstart <= fechaFin &&
          otherSchedule.fend >= fechaStart
        ) {
          newListOtherSchedule.push(otherSchedule);
        }
      });

      if (newListOtherSchedule.length > 0) {
        //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
        newListOtherSchedule.forEach((otherSchedule) => {
          //selecionar un color aleatorio para cada programacion
          const color = colors[Math.floor(Math.random() * colors.length)];
          colors.splice(colors.indexOf(color), 1);


          otherSchedule.events.forEach((event) => {
            daysProgram.push({
              id: index,
              idInstructor: idInstructor,
              title: nameInstructor,
              start: event.toISOString().split("T")[0],
              tstart: formatDate12Hours(otherSchedule.tstart),
              tend: formatDate12Hours(otherSchedule.tend),
              backgroundColor: color.background,
              borderColor: color.background,
              textColor: color.colortext,
              type: 1,
              autogenerated: false,
            });
            index++;
          });
        });
      }
    }

    res.json({
      events: daysProgram,
      msg: req.validation ? req.validation : "",
    });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get schedule by fiche
scheduleCtrl.getScheduleFiche = async (req, res) => {
  const { id } = req.params;
  try {
    const schedules = await Schedule.find({ fiche: id })
      .populate("fiche instructor program competence outcome environment")
      .sort({ createdAt: -1 });



    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//validate edit schedule
scheduleCtrl.getDataValidateEditSchedule = async (req, res) => {
  const {
    fiche,
    fstart,
    fend,
    instructor,
    program,
    competence,
    outcome,
    environment,
    days,
    tstart,
    tend,
  } = req.body;
  const idSchedule = req.params.id;

  let nameInstructor = "";
  let idInstructor = "";
  let colors = [...colorsEvents];

  try {
    const searchFiche = await Fiche.findById(fiche);

    const findInstructor = await Instructor.findById(instructor, { status: 0 });
    nameInstructor = findInstructor.name;
    idInstructor = findInstructor._id;

    let daysProgram = [];
    let currentDate = dateFormater(fstart);
    let fechaStart = dateFormater(fstart);
    let fechaFin = dateFormater(fend);
    let index = 1;

    //generar las fehcas start para el instructor que se desea programar
    const searchCompetence = await Competence.findById(competence, {
      status: 0,
    });
    const searchOutcome = await Outcome.findById(outcome, { status: 0 });
    const searchProgram = await Program.findById(program, { status: 0 });
    const searchEnvironment = await Environment.findById(environment, {
      status: 0,
    });

    while (currentDate <= fechaFin) {
      if (days.includes(currentDate.getUTCDay())) {
        //extraer solo lo que está entes del T
        let result = currentDate.toISOString().split("T")[0];
        daysProgram.push({
          id: index,
          fiche: searchFiche.number,
          idInstructor: idInstructor,
          program: searchProgram.name,
          environment: searchEnvironment.name,
          outcome: searchOutcome.outcomes,
          competence: searchCompetence.name,
          title: nameInstructor,
          start: result,
          tstart: formatDate12Hours(tstart),
          tend: formatDate12Hours(tend),
          type: 0,
          autogenerated: true,
        });
        index++;
      }
      // next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    //buscar los events de la misma ficha dentro del rango de fechas
    const programaFiche = await Schedule.find({
      fiche: fiche,
      status: 0,
    })
      .populate("fiche instructor program competence outcome environment")

    let newListProgramaFiche = [];
    programaFiche.forEach((progra) => {
      if (progra.fstart <= fechaFin && progra.fend >= fechaStart) {
        newListProgramaFiche.push(progra);
      }
    });

    //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
    newListProgramaFiche.forEach((progra) => {
      if (idSchedule.toString() != progra._id.toString()) {
        //selecionar un color aleatorio para cada instructor
        const color = colors[Math.floor(Math.random() * colors.length)];
        colors.splice(colors.indexOf(color), 1);
        progra.events.forEach((event) => {
          daysProgram.push(
            formatEventSchedule(progra,event, index, color, false)
          );
          index++;
        });
      }
    });

    /* 
    buscar los eventos de la misma ficha dentro del rango de fechas
    */

    const searchOtherSchedule = await OtherSchedules.find({
      instructor,
      status: 0,
    });

    let newListOtherSchedule = [];

    if (searchOtherSchedule.length > 0) {
      searchOtherSchedule.forEach((otherSchedule) => {
        if (
          otherSchedule.fstart <= fechaFin &&
          otherSchedule.fend >= fechaStart
        ) {
          newListOtherSchedule.push(otherSchedule);
        }
      });

      if (newListOtherSchedule.length > 0) {
        //extraer los eventos de cada programacion y crear un objeto con id, idInstructor, title, start
        newListOtherSchedule.forEach((otherSchedule) => {
          //selecionar un color aleatorio para cada programacion
          const color = colors[Math.floor(Math.random() * colors.length)];
          colors.splice(colors.indexOf(color), 1);

          otherSchedule.events.forEach((event) => {
            daysProgram.push({
              id: index,
              idInstructor: idInstructor,
              title: nameInstructor,
              start: event.toISOString().split("T")[0],
              tstart: formatDate12Hours(otherSchedule.tstart),
              tend: formatDate12Hours(otherSchedule.tend),
              backgroundColor: color.background,
              borderColor: color.background,
              textColor: color.colortext,
              type: 1,
              autogenerated: false,
            });
            index++;
          });
        });
      }
    }

    res.json({
      events: daysProgram,
      msg: req.validation ? req.validation : "",
    });
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get all schedules in the db
scheduleCtrl.getSchedules = async (req, res) => {
  const { status } = req.query;
  try {
    const schedules = await Schedule.find(status ? { status } : {})
      .populate("fiche instructor program competence outcome environment")
      .sort({ createdAt: -1 });
    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get ultimate 100 schedules in the db
scheduleCtrl.getSchedulesLimit = async (req, res) => {
  try {
    const schedules = await Schedule.find()
      .sort({ createdAt: -1 })
      .limit(100)
      .populate("fiche instructor program competence outcome environment");
    res.json(schedules);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//get schedule by id
scheduleCtrl.getScheduleId = async (req, res) => {
  const { id } = req.params;
  try {
    let schedule = await Schedule.findById(id)
      .populate("fiche instructor program competence outcome environment")

    let newSchedule = schedule.toObject();

    let newListEvents = [];
    let index = 1;

    newSchedule.events.forEach((event) => {
      newListEvents.push({
        id: index,
        idInstructor: schedule.instructor._id,
        fiche: schedule.fiche.number,
        program: schedule.program.name,
        environment: schedule.environment.name,
        outcome: schedule.outcome.outcomes,
        competence: schedule.competence.name,
        title: schedule.instructor.name,
        start: event.toISOString().split("T")[0], //"2023-05-01"
        tstart: formatDate12Hours(schedule.tstart),
        tend: formatDate12Hours(schedule.tend),
        type: 0,
        autogenerated: true,
      });
      index++;
    });

    newSchedule.events = newListEvents;
    res.json(newSchedule);
  } catch (error) {
    console.log(error);
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//active schedule in the db
scheduleCtrl.activeSchedule = async (req, res) => {
  const { id } = req.params;
  try {
    const schedule = await Schedule.findByIdAndUpdate(
      id,
      { status: 0 },
      { new: true }
    );

    //sumar las horas de trabajo del instructor
    const instructor = await Instructor.findById(schedule.instructor);
    const newHourswork = instructor.hourswork + schedule.hourswork;
    await Instructor.findByIdAndUpdate(schedule.instructor, {
      hourswork: newHourswork,
    });

    if (newHourswork > instructor.caphour) {
      return res.json({
        msg: "Horario activado correctamente",
        alert: "El instructor ha superado su limite de horas",
      });
    }
    await registerAction(
      "HORARIO",
      {
        event: "ACTIVAR HORARIO",
        data: { id},
      },
      req.headers.token
    );
    return res.json({ msg: "Horario activado correctamente" });
  } catch (error) {
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//inactivate schedule in the db
scheduleCtrl.inactiveSchedule = async (req, res) => {
  const { id } = req.params;
  try {
    const schedule = await Schedule.findByIdAndUpdate(
      id,
      { status: 1 },
      { new: true }
    );

    //restar las horas de trabajo del instructor
    const instructor = await Instructor.findById(schedule.instructor);
    const newHourswork = instructor.hourswork - schedule.hourswork;
    await Instructor.findByIdAndUpdate(schedule.instructor, {
      hourswork: newHourswork,
    });
    await registerAction(
      "HORARIO",
      {
        event: "INACTIVAR HORARIO",
        data: { id},
      },
      req.headers.token
    );
    res.json({ msg: "Horario inactivado correctamente" });
  } catch (error) {
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

//delete schedule in the db
scheduleCtrl.deleteEventSchedule = async (req, res) => {
  const { id } = req.params;
  const { event } = req.body;
  const eventFormat = `${event}T00:00:00.000Z`;

  try {
    const schedule = await Schedule.findById(id);
    const instructor = await Instructor.findById(schedule.instructor);
    let oldHourswork = instructor.hourswork;

    if (schedule.events.length >= 1) {
      const newEvents = schedule.events.filter((event) => {
        return event.toISOString() != eventFormat;
      });

      const hourswork = calculateNumHoursWork(
        schedule.tstart,
        schedule.tend,
        newEvents.length
      );

      //restar las horas de trabajo del instructor
      oldHourswork -= schedule.hourswork - hourswork;

      await Instructor.findByIdAndUpdate(instructor._id, {
        hourswork: oldHourswork,
      });

      await Schedule.findByIdAndUpdate(id, {
        fstart: newEvents[0],
        fend: newEvents[newEvents.length - 1],
        events: newEvents,
        hourswork,
      });
      await registerAction(
        "HORARIO",
        {
          event: "ELIMINAR EVENTO",
          data: { id, event },
        },
        req.headers.token
      );
      return res.json({ msg: "Evento eliminado correctamente" });
    } else {
      return res.status(400).json({
        msg: "Solo queda un evento en la programacion, no se puede eliminar",
      });
    }
  } catch (error) {
    res.status(400).json({ msg: "No fue posible terminar la operacion" });
  }
};

export { scheduleCtrl };
